/*
Filename:        fish_i_main.nss
System:          SM's Fishing System (include script)
Author:          Michael A. Sinclair (Squatting Monk) <squattingmonk@gmail.com>
Date Created:    Aug. 12, 2015
Summary:
Fishing System include script. This file holds functions and constants commonly
used in the system. This file should not be altered by end users. For
configurable settings and functions, see fish_c_config.

This script is consumed as an include directive by fish_c_config.

Revision Info should only be included for post-release revisions.
-----------------
Revision Date:
Revision Author:
Revision Summary:

*/

// List handling utilities
#include "util_i_lists"

// -----------------------------------------------------------------------------
//                                  Constants
// -----------------------------------------------------------------------------

// Blueprints and tags
const string FISH_WP_DATA    = "fish_datapoint";
const string FISH_WP_FISHING = "fish_fishingspot";
const string FISH_WP_GENERIC = "nw_waypoint001";

// Local variables names.
const string FISH_BAIT        = "BAIT";
const string FISH_DEBUG       = "DEBUG";
const string FISH_ENVIRONMENT = "ENV";
const string FISH_EQUIPMENT   = "EQU";
const string FISH_INHERITS    = "INHERITS";
const string FISH_MESSAGE     = "MSG";

// Fishing bait preferences for equipment
const int FISH_BAIT_IS_REQUIRED = 1;
const int FISH_BAIT_IS_OPTIONAL = 2;
const int FISH_BAIT_IS_IGNORED  = 3;

// Fishing events for animation
const int FISH_EVENT_START     = 0;
const int FISH_EVENT_NIBBLE    = 1;
const int FISH_EVENT_CATCH     = 2;
const int FISH_EVENT_NO_CATCH  = 3;
const int FISH_EVENT_NO_NIBBLE = 4;

struct FishingData
{
    // We store all our data on a waypoint accessed through the global variable
    // Fish.Data. The waypoint is auto-generated by InitializeFishingSystem().
    // We do this to reduce the number of local variables stored on the module,
    // which helps reduce access time when dealing with large numbers of
    // variables.
    object Data;

    object PC;          // the PC currently fishing
    object Spot;        // The current fishing spot
    string Environment; // The environment the PC is fishing in
    object Item;        // The PC's current fishing equipment
    string Type;        // The type of equipment the PC is using
    string Bait;        // What the equipment is baited with
    int    Debug;       // Whether to debug fishing functions
    int    Usage;       // Whether the PC's fishing equipment uses bait.
};


// -----------------------------------------------------------------------------
//                              Global Variables
// -----------------------------------------------------------------------------

// Data structure to hold all variables for this fishing attempt. We instatiate
// it here so it is accessible to all the functions within this script. All data
// is set by fish_t_equipment.nss. The user should use the GetFishing*()
// functions instead of accessing this variable directly.
struct FishingData Fish;

// -----------------------------------------------------------------------------
//                             Function Prototypes
// -----------------------------------------------------------------------------

// ----- System Functions ------------------------------------------------------

// These functions should only be used by the internal system.

// ---< InitializeFishingSystem >---
// ---< fish_i_main >---
// Runs the config function OnFishingSetup() if it has not been run yet, turning
// on debug mode if bDebugMode is TRUE or if oPC or oEquipment has a local int
// named "DEBUG" set to TRUE. Returns whether this was its first run.
// Note: This is an internal function and should not be used by the builder.
int InitializeFishingSystem(object oPC, object oEquipment, int bDebugMode);

// ---< HandleFishingBait >---
// ---< fish_i_main >---
// If the item the PC is currently using is a bait item, checks to see if the
// item can be used with the currently equipped item. If so, it applies the bait
// and sends the message sSuccess to the PC. If not, it re-creates the item in
// the PC's inventory and sends the message sError. Returns whether this was a
// bait item.
// Note: This is an internal function and should not be used by the builder.
int HandleFishingBait(string sSuccess, string sError);

// ---< VerifyFishingSpot >---
// ---< fish_i_main >---
// Returns whether the nearest fishing spot is within fMax meters of the PC.
// Note: This is an internal function and should not be used by the builder.
int VerifyFishingSpot(float fMax);

// ---< VerifyFishingBait >---
// ---< fish_i_main >---
// Returns whether the PC's fishing equipment has bait (if it so requires).
// Note: This is an internal function and should not be used by the builder.
int VerifyFishingBait();

// ---< MergeFishList >---
// ---< fish_i_main >---
// Merges sSource's fish list into sTarget's fish list of sListType (can be an
// environment, bait, or type of equipment). Fish are not added twice:
// if a fish exists in sTarget's list, its frequency or modifiers will not be
// overwritten by those in sSource's list.
// Note: This is an internal function and should not be used by the builder.
void MergeFishList(string sTarget, string sSource, string sListType);

// ---< BuildFishList >---
// ---< fish_i_main >---
// Resolves inheritance lists for sItem (can be an environment, bait, or type of
// equipment) compiling a list of fish parent types. Fish are not added twice:
// the lowest level of inheritance takes precedence when determining fish's
// frequency or modifiers. Returns the count of the newly added fish list.
// Note: This is an internal function and should not be used by the builder.
int BuildFishList(string sItem, string sListType);

// ---< ActionFish >---
// ---< fish_i_main >---
// Does the actual fishing. This function runs OnActivate when oEquipment is
// used. We place it into a separate function so we can AssignCommand() it to
// the PC and refer to him as OBJECT_SELF.
// Note: This is an internal function and should not be used by the builder.
void ActionFish(string sPrefix);


// ----- Config Function Utilities ---------------------------------------------

// These functions are usable within the config functions listed below.

// ---< FishDebug >---
// ---< fish_i_main >---
// If debug mode is on, sends sMessage to the PC. This is done using the action
// queue, so the PC will see the message at the appropriate time.
void FishDebug(string sMessage);

// ---< InheritFish >---
// ---< fish_i_main >---
// Sets every item in the CSV list sChildren as inheriting fish from sParent's
// list. You can chain inheritance (i.e., "Murkwater Lake" inherits from "lake"
// which inherits from "freshwater"), but ensure that no two items inherit from
// each other, even indirectly, or the system will loop infinitely when climbing
// the inheritance tree.
//
// The parent and children can be environments, baits, or equipment types, but
// do not let different types inherit from each other (e.g., a bait inherit from
// an environment) or Bad Things Will Happen (TM).
//
// When determining a fish's environment frequency or bait modifier, the system
// climbs the inheritance tree from child to parent to grandparent. The first
// item with the fish takes precedence. For example, if "trout" is not defined
// in "Murkwater Lake" but is defined in both "lake" and "freshwater", its
// frequency in "lake" will take precedence over its frequency in "freshwater".
// You can thus use this to override environment frequencies and bait modifiers,
// making fish more or less likely to be caught.
//
// Example usage for environments:
// InheritFish("lake, pond, river", "freshwater");
// InheritFish("Murkwater Lake", "lake");
// In this case, every fish found in "freshwater" can also be found in "lake",
// "pond", and "river"; every fish found in "freshwater" or "lake" can also be
// found in "Murkwater Lake".
//
// Example usage for baits:
// InheritFish("insect, worm, minnow", "live_bait");
// InheritFish("mayfly, beetle", "insect");
// In this case, every fish that eats "live_bait" will also eat "insect", "worm"
// and "minnow"; every fish that eats in "insect" or "live bait" will also eat
// "mayfly" and "beetle".
//
// Example usage for equipment:
// InheritFish("light_pole, standard_pole, heavy_pole", "pole");
// InheritFish("cane_pole, willow_rod", "light_pole");
// In this case, every fish that can be caught with a "pole" can also be caught
// with a "light_pole"; every fish that can be caught with a "pole" or
// "light_pole" can also be caught with a "cane_pole" or "willow_rod".
void InheritFish(string sChildren, string sParent);

// ---< GetInheritsFish >---
// ---< fish_i_main >---
// Returns whether sChild (an environment, bait, or equipment type) inherits
// fish from sParent, however remotely.
int GetInheritsFish(string sChild, string sParent);

// ---< AddFishEnvironments >---
// ---< fish_i_main >---
// Adds fish to a list of possible fishing environments and sets the frequency
// with which they bite in that environment. Players can only catch fish in the
// environments where they live.
// - sFishList: a comma-separated list of the blueprints used to create the fish
//   on a successful catch.
// - sEnvironmentList: a comma-separated list of environments for the fish.
// - nFrequency: the percentage of the time a fish will be found in this
//   environment. A value of 0 or lower will guarantee that a fish will not be
//   caught unless its probability is raised in some way, and a value of 100 or
//   higher will guarantee the fish will be caught unless its probability is
//   decreased in some way. Default: 0
void AddFishEnvironments(string sFishList, string sEnvironmentList, int nFrequency = 0);

// ---< AddFishBaits >---
// ---< fish_i_main >---
// Modifies the percentage of the time a fish bites when using a given bait.
// - sFishList: a comma-separated list of the blueprints used to create the fish
//   on a successful catch.
// - sBaitList: a comma-separated list of baits the fish may bite on.
// - nModifier: a modifier to the percentage of the time a fish will bite. (see
//   the notes on AddFishEnvironments().
// Note: if no baits are added for a fish, players cannot catch it when using
// equipment in FISH_BAIT_REQUIRED.
void AddFishBaits(string sFishList, string sBaitList, int nModifier = 0);

// ---< AddFishEquipment >---
// ---< fish_i_main >---
// Requires the PC to be fishing with one of the items in sEquipmentList in
// order to catch any fish in sFishList. If a fish does not have any required
// equipment, it can be caught using any equipment.
void AddFishEquipment(string sFishList, string sEquipmentList, int nModifier = 0);

// ---< GetFishingSpot >---
// ---< fish_i_main >---
// Returns the fishing spot object where the PC is currently fishing.
object GetFishingSpot();

// ---< GetFishingEnvironment >---
// ---< fish_i_main >---
// Returns the environment of the given fishing spot. If oSpot is invalid,
// returns the environment of the spot the PC is currently fishing in.
string GetFishingEnvironment(object oSpot = OBJECT_INVALID);

// ---< GetFishingEquipment >---
// ---< fish_i_main >---
// Returns the fishing equipment the PC is currently using to fish.
object GetFishingEquipment();

// ---< GetFishingEquipmentType >---
// ---< fish_i_main >---
// Returns the type of the given fishing equipment. If oEquipment is invalid,
// will return the type of equipment the PC is currently using to fish. You can
// create your own types of fishing equipment: simply give your item a "Cast
// Spell: OnActivate (Self Only)" item property with unlimited uses and set its
// tag to "fish_t_equipment_X", where X is the type of equipment your item is.
// That value should then be compared with the return value of this function to
// see whether that type of equipment is being used.
string GetFishingEquipmentType(object oEquipment = OBJECT_INVALID);

// ---< GetFishingBaitType >---
// ---< fish_i_main >---
// Returns the type of bait represented by the given bait item.
string GetFishingBaitType(object oBait);

// ---< GetFishingBaitUsage >---
// ---< fish_i_main >---
// Returns a FISH_BAIT_IS_* constant showing whether bait is required, ignored,
// or optional for oEquipment. If oEquipment is invalid, checks the PC's
// currently equipped fishing item.
int GetFishingBaitUsage(object oEquipment = OBJECT_INVALID);

// ---< GetFishBaitRequired >---
// ---< fish_i_main >---
// Returns whether bait is required for oEquipment. If oEquipment is invalid,
// checks the PC's currently equipped fishing item.
int GetFishBaitRequired(object oEquipment = OBJECT_INVALID);

// ---< GetFishingBait >---
// ---< fish_i_main >---
// Returns the bait being used on the given fishing equipment. If oEquipment is
// invalid, returns the bait on the PC's currently equipped fishing equipment.
// You can create your own types of fishing bait: simply give your item a "Cast
// Spell: OnActivate (Self Only)" item property with a single use and set its
// tag to "fish_t_equipment_bait_X", where X is the type of bait your item is.
// That value should then be compared with the return value of this function to
// see whether that type of bait is being used.
string GetFishingBait(object oEquipment = OBJECT_INVALID);

// ---< SetFishingBait >---
// ---< fish_i_main >---
// Sets the sBait as being used on the given fishing equipment. If oEquipment is
// invalid, sets sBait on the PC's currently equipped fishing equipment.
void SetFishingBait(string sBait, object oEquipment = OBJECT_INVALID);

// ---< GetFishFloat >---
// ---< fish_i_main >---
// Gets a local float of sVarName from sFish. If sFish is blank, will get the
// float from the fish data point.
float GetFishFloat(string sVarName, string sFish = "");

// ---< GetFishInt >---
// ---< fish_i_main >---
// Gets a local int of sVarName from sFish. If sFish is blank, will get the int
// from the fish data point.
int GetFishInt(string sVarName, string sFish = "");

// ---< GetFishString >---
// ---< fish_i_main >---
// Gets a local string of sVarName from sFish. If sFish is blank, will get the
// string from the fish data point.
string GetFishString(string sVarName, string sFish = "");

// ---< SetFishFloat >---
// ---< fish_i_main >---
// Sets a local float of sVarName with fValue on every fish in sFishList. If
// sFishList is blank, will set the float on the fish data point.
void SetFishFloat(string sVarName, float fValue, string sFishList = "");

// ---< SetFishInt >---
// ---< fish_i_main >---
// Sets a local int of sVarName with nValue on every fish in sFishList. If
// sFishList is blank, will set the int on the fish data point.
void SetFishInt(string sVarName, int nValue, string sFishList = "");

// ---< SetFishString >---
// ---< fish_i_main >---
// Sets a local string of sVarName with sValue on every fish in sFishList. If
// sFishList is blank, will set the string on the fish data point.
void SetFishString(string sVarName, string sValue, string sFishList = "");

// ---< GetFishByEnvironment >---
// ---< fish_i_main >---
// Returns a comma-separated list of fish found in sEnvironment. If sEnvironment
// is blank, will search the environment the PC is currently fishing in.
string GetFishByEnvironment(string sEnvironment = "");

// ---< GetFishByBait >---
// ---< fish_i_main >---
// Returns a comma-separated list of fish that eat sBait. If sBait is blank,
// will search the bait the PC is currently fishing with. Remember, if a fish is
// not given a bait list, it can be caught with any bait, but will not show up
// in this list.
string GetFishByBait(string sBait = "");

// ---< GetFishByEquipment >---
// ---< fish_i_main >---
// Returns a comma-separated list of fish catchable with sType of equipment. If
// sType is blank, will search the type of equipment the PC is currently fishing
// with. Remember, if a fish is not given an equipment list, it can be caught
// with any type of equipment, but will not show up in this list.
string GetFishByEquipment(string sType = "");

// ---< ActionFloatingTextString >---
// ---< fish_i_main >---
// Inserts FloatingTextStringOnCreature() into OBJECT_SELF's action queue. Will
// not broadcast sMessage to the PC's faction. You can use this to provide
// flavor text to your PCs.
void ActionFloatingTextString(string sMessage);

// ---< ActionRemoveFishingBait >---
// ---< fish_i_main >---
// Removes the bait from the PC's fishing equipment. This is inserted into the
// action queue so the PC can retain his bait if he aborts the fishing sequence.
void ActionRemoveFishingBait();

// ---< ActionCreateFish >---
// ---< fish_i_main >---
// Creates a fish from sResRef on the PC. This is inserted into the action queue
// so the PC will not catch the fish if he aborts the fishing sequence.
void ActionCreateFish(string sResRef);

// ---< ObjectToAction >---
// ---< fish_i_main >---
// Convert oObject into a void. Use this to pass an object-returning function as
// a parameter to an ActionDoCommand() function.
void ObjectToAction(object oObject);


// ----- Config Functions ------------------------------------------------------

// These functions are defined in fish_c_config, but we declare them here so we
// can use them in our internal functions.

// ---< OnFishingSetup >---
// ---< fish_c_config >---
// This is a configurable function you can use to alter the fish, environments,
// and baits used in your module. All of the following code will run the first
// time a fishing pole is used in your module.
void OnFishingSetup();

// ---< OnFishingStart >---
// ---< fish_c_config >---
// This is a configurable function that runs when the PC uses fishing equipment.
// Returns whether the PC is able to fish. Example uses include setting a max
// distance to the fishing spot based on his equipment, providing flavor text
// about the cast, adding additional restrictions for fishing, or setting a time
// limit between fish bites.
// - OBJECT_SELF: the PC fishing
int OnFishingStart();

// ---< OnFishNibble >---
// ---< fish_c_config >---
// This is a configurable function that allows you to modify the chances a type
// of fish will bite. Example uses include giving fish preferences for different
// types of bait, making fish more or less likely to bite at different times of
// day or month, or keeping a type of fish from biting if it's been "fished out"
// of the spot.
// - OBJECT_SELF: the PC attempting to catch the fish.
// - sFish: the resref of the fish whose chances to bite we're testing.
// Returns: an amount to add to the chance the fish will bite.
int OnFishNibble(string sFish);

// ---< OnFishNibbleFail >---
// ---< fish_c_config >---
// This is a configurable function to handle what happens when the PC fails to
// get a fish to nibble on the line. Example uses include notifying the PC of
// his failure, adding a chance of losing his bait, or having him catch seaweed
// or an old boot instead.
// - OBJECT_SELF: the PC who failed to catch a fish.
void OnFishNibbleFail();

// ---< OnFishNibbleSuccess >---
// ---< fish_c_config >---
// This is a configurable function to handle what happens when a PC gets a fish
// on the line. Returns whether the PC is successful at catching the fish.
// Example uses include giving flavor text about the fish, requiring an ability
// check to catch it, or setting the fishing spot as unavailable for a time.
// - OBJECT_SELF: the PC fishing.
// - sFish: the resref of the fish the PC has on the line.
int OnFishNibbleSuccess(string sFish);

// ---< OnFishCatch >---
// ---< fish_c_config >---
// This is a configurable function to intercept the actual creation of the fish.
// Returns whether the system should create the fish. Example uses include
// removing the PC's bait, copying a fish from a container rather than creating
// one from a blueprint (to save on palette items), increasing a persistently
// stored fishing skill, or even just giving the player some XP.
int OnFishCatch(string sFish);

// ---< PlayFishingAnimation >---
// ---< fish_c_config >---
// This is a configurable function to handle the animations for different stages
// of the fishing. nEvent is the fishing event which is currently playing:
// FISH_EVENT_START: plays when fishing begins (after OnFishingStart())
// FISH_EVENT_NIBBLE: plays when a fish has passed the nibble check
// FISH_EVENT_CATCH: plays when a PC successfully catches a fish
// FISH_EVENT_NO_CATCH: plays when a fish nibbled but was not caught
// FISH_EVENT_NO_NIBBLE: plays when no fish nibbled at all
void PlayFishingAnimation(int nEvent);

// -----------------------------------------------------------------------------
//                          Function Implementations
// -----------------------------------------------------------------------------

// ----- Private System Functions ----------------------------------------------

int InitializeFishingSystem(object oPC, object oItem, int bConfig)
{
    // Should we debug?
    Fish.Debug = bConfig                        ? TRUE :
                 GetLocalInt(oPC,   FISH_DEBUG) ? TRUE :
                 GetLocalInt(oItem, FISH_DEBUG);

    // Add the PC and his equipment to our globals
    Fish.PC   = oPC;
    Fish.Item = oItem;

    // Make sure the fishing datapoint is set up
    Fish.Data = GetWaypointByTag(FISH_WP_DATA);
    if (!GetIsObjectValid(Fish.Data))
    {
        Fish.Data = CreateObject(OBJECT_TYPE_WAYPOINT, FISH_WP_GENERIC, GetStartingLocation(), FALSE, FISH_WP_DATA);

        // Run our config function.
        OnFishingSetup();
        return TRUE;
    }

    // Our waypoint already exists, so this is not the first time we've run.
    return FALSE;
}

int HandleFishingBait(string sSuccess, string sError)
{
    // Add the equipment type to our globals.
    Fish.Type = GetFishingEquipmentType(Fish.Item);
    FishDebug("Handling bait for equipment: " + Fish.Type);

    // If this isn't bait, abort.
    if (Fish.Type != "bait")
        return FALSE;

    // See if we've got a baitable item in our hand.
    object oEquipment = GetItemInSlot(INVENTORY_SLOT_RIGHTHAND, Fish.PC);

    if (GetIsObjectValid(oEquipment) &&
        GetFishingBaitUsage(oEquipment) != FISH_BAIT_IS_IGNORED)
    {
        // We can use bait on this item! Set our bait and finish.
        string sBait = GetFishingBaitType(Fish.Item);
        SetLocalString(oEquipment, FISH_BAIT, sBait);
        FloatingTextStringOnCreature(sSuccess, Fish.PC);
    }
    else
    {
        // Recreate the bait in the PC's inventory. Make sure it has the
        // same tag in case this is a modified instantiation of a blueprint.
        // TODO: prevent duping exploit for multi-use bait
        CreateItemOnObject(GetResRef(Fish.Item), Fish.PC, 1, GetTag(Fish.Item));
        FloatingTextStringOnCreature(sError, Fish.PC);
    }

    return TRUE;
}

int VerifyFishingSpot(float fMax)
{
    // Find the nearest fishing spot
    // TODO: add ability to use a trigger rather than a waypoint
    Fish.Spot = GetNearestObjectByTag(FISH_WP_FISHING, Fish.PC);
    Fish.Environment = GetFishingEnvironment(Fish.Spot);

    // Make sure it's not too far away.
    return (GetIsObjectValid(Fish.Spot) && GetDistanceBetween(Fish.PC, Fish.Spot) <= fMax);
}

int VerifyFishingBait()
{
    // Initialize our equipment
    Fish.Bait = GetFishingBait(Fish.Item);
    Fish.Usage = GetFishingBaitUsage(Fish.Item);

    return (Fish.Bait != "" || Fish.Usage != FISH_BAIT_IS_REQUIRED);
}

void MergeFishList(string sTarget, string sSource, string sListType)
{
    FishDebug("Merging " + sSource + "'s " + sListType + " list into " + sTarget + "'s list");
    int i, nFreq, nCount = GetStringListCount(Fish.Data, sListType + sSource);
    string sFish;

    for (i = 0; i < nCount; i++)
    {
        FishDebug("Processing item " + IntToString(i));

        // Get the fish from the listed parent and try adding it to the
        // child's fish list.
        sFish = GetStringListItem(Fish.Data, i, sListType + sSource);
        if (AddStringListItem(Fish.Data, sFish, sListType + sTarget, TRUE))
        {
            FishDebug("Adding " + sTarget + " to " + sFish + "'s " + sListType + " list.");

            // We need to add the item to the fish's list.
            AddStringListItem(Fish.Data, sTarget, sFish + sListType);

            // Set the frequency or modifier.
            nFreq = GetLocalInt(Fish.Data, sFish + sListType + sSource);
                    SetLocalInt(Fish.Data, sFish + sListType + sTarget, nFreq);
        }
    }
}

// Multiple inheritance version
int BuildFishList(string sItem, string sListType)
{
    // Sanity check
    if (sItem == "") return 0;

    // See if this list has already been built. If so, we can short-circuit.
    if (GetLocalInt(Fish.Data, sItem))
        return GetStringListCount(Fish.Data, sListType + sItem);

    // It hasn't. Let's check any parents it has and merge them into the list.
    string sParent, sParents = GetLocalString(Fish.Data, sItem + FISH_INHERITS);
    int i, nCount = GetListCount(sParents);
    for (i = 0; i < nCount; i++)
    {
        // The parent must be resolved before we can merge it into the child.
        sParent = GetListItem(sParents, i);
        FishDebug("Building " + sListType + " list for " + sParent);
        BuildFishList(sParent, sListType);
        MergeFishList(sItem, sParent, sListType);
    }

    // Mark the list as built.
    SetLocalInt(Fish.Data, sItem, TRUE);
    return GetStringListCount(Fish.Data, sListType + sItem);
}

void ActionFish(string sPrefix)
{
    // Run the config function to see if we're allowed to fish.
    if (!OnFishingStart()) return;

    // Environments can be combined into a comma-separated list. Let's check if
    // this environment's fish list has been built. If not, we need to make sure
    // any contributing environments are set up before building the fish list.
    int i, nCount = GetListCount(Fish.Environment);
    if (nCount > 1 && !GetLocalInt(Fish.Data, Fish.Environment))
    {
        // Iterate through the list, build the component environment, and merge.
        FishDebug("Building combined environment " + Fish.Environment);
        string sEnvironment;
        for (i = 0; i < nCount; i++)
        {
            sEnvironment = GetListItem(Fish.Environment, i);
            BuildFishList(sEnvironment, FISH_ENVIRONMENT);
            MergeFishList(Fish.Environment, sEnvironment, FISH_ENVIRONMENT);
        }
    }

    // Resolve fish inheritance for our environment, equipment, and bait.
    nCount = BuildFishList(Fish.Environment, FISH_ENVIRONMENT);
             BuildFishList(Fish.Type,        FISH_EQUIPMENT);
             BuildFishList(Fish.Bait,        FISH_BAIT);

    // Only bother calculating this stuff if debug mode is on.
    if (Fish.Debug)
    {
        FishDebug("\nTrying to fish in a "+ Fish.Environment + " using a " + Fish.Type + " baited with " + Fish.Bait);
        FishDebug("Fish in this environment: " + GetFishByEnvironment(Fish.Environment));
        FishDebug("Fish that like this bait: " + GetFishByBait(Fish.Bait));
    }

    // To keep fish earlier in the list from dominating, let's pick a random
    // index and start iterating from there.
    int nStart = Random(nCount);

    // Test for a nibble
    string sFish;
    float  fChance = 1.0;
    int    nFreq, nMod, nChance;

    // Loop through the fish in the environment.
    for (i = 0; i < nCount; i++)
    {
        sFish = GetStringListItem(Fish.Data, (nStart + i) % nCount, FISH_ENVIRONMENT + Fish.Environment);

        FishDebug("\nTrying to catch a " + sFish);

        // If this fish has a set list of items that can catch it...
        if (GetStringListCount(Fish.Data, sFish + FISH_EQUIPMENT))
        {
            // If the fish cannot be caught using the given equipment, skip it.
            if (!IsStringInList(Fish.Data, Fish.Type, sFish + FISH_EQUIPMENT))
            {
                FishDebug(sFish + " cannot be caught using equipment: " + Fish.Type);
                continue;
            }

            // Otherwise, get the modifier for this equipment.
            nMod = GetFishInt(FISH_EQUIPMENT + Fish.Type, sFish);
        }

        // If this fishing equipment can use bait...
        if (Fish.Usage != FISH_BAIT_IS_IGNORED)
        {
            // If bait is required, do we have the proper bait?
            if (Fish.Usage == FISH_BAIT_IS_REQUIRED &&
                GetStringListCount(Fish.Data, sFish + FISH_BAIT) &&
                !IsStringInList(Fish.Data, Fish.Bait, sFish + FISH_BAIT))
            {
                FishDebug(sFish + " cannot be caught using bait: " + Fish.Bait);
                continue;
            }

            // We can use this bait!
            nMod += GetFishInt(FISH_BAIT + Fish.Bait, sFish);
        }

        // Get the frequency the fish bites and allow the user to modify it.
        nFreq = GetFishInt(FISH_ENVIRONMENT + Fish.Environment, sFish);
        nMod += OnFishNibble(sFish);
        nChance = nFreq + nMod;

        FishDebug("nFreq: "  + IntToString(nFreq) +
                  " nMod: "  + IntToString(nMod) +
                  " = "      + IntToString(nChance) +
                  "% chance of catching this fish.");

        // Check whether the fish bites.
        if (Random(100) < nChance)
        {
            FishDebug("Success! Checking if we can reel in the " + sFish);

            // A fish took our line! Let's check if we catch it.
            PlayFishingAnimation(FISH_EVENT_NIBBLE);
            if (OnFishNibbleSuccess(sFish))
            {
                FishDebug("Success! Reeling in the " + sFish);
                PlayFishingAnimation(FISH_EVENT_CATCH);
                if (OnFishCatch(sFish))
                    ActionCreateFish(sPrefix + sFish);
            }
            else
                PlayFishingAnimation(FISH_EVENT_NO_CATCH);

            return;
        }
        else if (Fish.Debug)
            fChance *= (IntToFloat(100 - nChance) / 100);
    }

    // No fish bit. Run the failure config function.
    FishDebug("\nNo fish bit! The chance of this happening was " + FloatToString(fChance * 100, 0, 2) + "%");
    OnFishNibbleFail();
    PlayFishingAnimation(FISH_EVENT_NO_NIBBLE);
}


// ----- Config Function Utilities ---------------------------------------------

void FishDebug(string sMessage)
{
    if (Fish.Debug)
        ActionDoCommand(SendMessageToPC(Fish.PC, sMessage));
}

void InheritFish(string sChildren, string sParents)
{
    SetFishString(FISH_INHERITS, sParents, sChildren);
}

int GetInheritsFish(string sChild, string sParent)
{
    // Sanity check
    if (sChild == "" || sParent == "")
        return FALSE;

    string sTest, sParents = GetLocalString(Fish.Data, sChild + FISH_INHERITS);
    int i, nCount = GetListCount(sParents);
    for (i = 0; i < nCount; i++)
    {
        sTest = GetListItem(sParents, i);
        FishDebug("Checking whether " + sTest + " inherits from " + sParent);
        return (sTest == sParent || GetInheritsFish(sTest, sParent));
    }

    // The child has no parents.
    return FALSE;
}

// Private function called by AddFish*() functions to populate fish lists.
void ExplodeFishList(string sFishList, string sItemList, string sListType, int nValue)
{
    if (sFishList == "" || sItemList == "") return;

    string sFish, sItem;
    int i, nFish = GetListCount(sFishList);
    int j, nItem = GetListCount(sItemList);

    for (i = 0; i < nFish; i++)
    {
        sFish = GetListItem(sFishList, i);
        for (j = 0; j < nItem; j++)
        {
            sItem = GetListItem(sItemList, j);

            // Add the item to the fish's list and vice versa
            if (AddStringListItem(Fish.Data, sFish, sListType + sItem, TRUE))
                AddStringListItem(Fish.Data, sItem, sListType + sFish);

            // Add the frequency or modifier for this item to the fish.
            SetLocalInt(Fish.Data, sFish + sListType + sItem, nValue);
        }
    }
}

// Sets the following each run:
// Name                      Type         Purpose
// "ENV<environment>"        string list  all fish in <environment>
// "<fish>ENV"               string list  all environments where <fish> is found
// "<fish>ENV<environment>"  int          frequency of <fish> in <environment>
void AddFishEnvironments(string sFishList, string sEnvironmentList, int nFrequency = 0)
{
    FishDebug("Adding " + sFishList + " to " + sEnvironmentList);
    ExplodeFishList(sFishList, sEnvironmentList, FISH_ENVIRONMENT, nFrequency);
}

// Sets the following data for each fish and bait:
// Name                Type         Purpose
// "BAIT<bait>"        string list  all fish that eat <bait>
// "<fish>BAIT"        string list  all bait that can catch <fish>
// "<fish>BAIT<bait>"  int          <fish>'s preference for <bait>
void AddFishBaits(string sFishList, string sBaitList, int nModifier = 0)
{
    ExplodeFishList(sFishList, sBaitList, FISH_BAIT, nModifier);
}

// Sets the following each run
// Name                    Type         Purpose
// "EQU<equipment>"        string list  all fish catchable with <equipment>
// "<fish>EQU"             string list  all equipment that can catch <fish>
// "<fish>EQU<equipment>"  int          modifier to catch <fish> with <equipment>
void AddFishEquipment(string sFishList, string sEquipmentList, int nModifier = 0)
{
    ExplodeFishList(sFishList, sEquipmentList, FISH_EQUIPMENT, nModifier);
}

void AddFishingMessage(int nEvent, string sKeyList, string sMessage)
{
    if (sMessage == "")
        return;

    string sKey, sName = FISH_MESSAGE + IntToString(nEvent);
    int i, nCount = GetListCount(sKeyList);
    for (i = 0; i < nCount; i++)
    {
        sKey = GetListItem(sKeyList, i);
        AddStringListItem(Fish.Data, sMessage, sName + sKey);
    }
}

string GetFishingMessage(int nEvent, string sKey)
{
    string sName = FISH_MESSAGE + IntToString(nEvent);
    int nCount = GetStringListCount(Fish.Data, sName + sKey);

    // If we don't have any messages for this key, see if we inherited any.
    while (!nCount)
    {
        sKey = GetLocalString(Fish.Data, sKey + FISH_INHERITS);
        if (sKey == "") return "";

        nCount = GetStringListCount(Fish.Data, sName + sKey);
    }

    // Get a random message from the list.
    return GetStringListItem(Fish.Data, Random(nCount), sName + sKey);
}

object GetFishingSpot()
{
    return Fish.Spot;
}

string GetFishingEnvironment(object oSpot = OBJECT_INVALID)
{
    if (!GetIsObjectValid(oSpot))
        return Fish.Environment;

    return GetName(oSpot);
}

object GetFishingEquipment()
{
    return Fish.Item;
}

string GetFishingEquipmentType(object oEquipment = OBJECT_INVALID)
{
    if (!GetIsObjectValid(oEquipment))
        return Fish.Type;

    // Everything after "fish_t_equipment_" in the tag is the type
    string sTag  = GetTag(oEquipment);
    string sType = GetStringRight(sTag, GetStringLength(sTag) - 17);

    // If we have nothing after the tag, default to the resref.
    sType = (sType == "" ? GetResRef(oEquipment) : sType);

    // If the first four characters are "bait", this is a bait item. Anything
    // after that will be the bait's type.
    if (GetStringLeft(sType, 4) == "bait")
        sType = "bait";

    return sType;
}

string GetFishingBaitType(object oBait)
{
    // Everything after "fish_t_equipment_" in the tag is the type
    string sTag  = GetTag(oBait);
    string sType = GetStringRight(sTag, GetStringLength(sTag) - 17);

    // If we have nothing after the tag, default to the resref.
    sType = (sType == "" ? GetResRef(oBait) : sType);

    // If the first four characters are "bait", this is a bait item. Anything
    // after that will be the bait's type.
    if (GetStringLeft(sType, 4) == "bait")
        return GetStringRight(sTag, GetStringLength(sType) - 5);

    // This is not bait.
    return "";
}

int GetFishingBaitUsage(object oEquipment = OBJECT_INVALID)
{
    if (!GetIsObjectValid(oEquipment))
        return Fish.Usage;

    // Handle any equipment whose setting has not been specified.
    string sType  = GetFishingEquipmentType(oEquipment);
    int    nUsage = GetFishInt(FISH_BAIT, sType);
    return (nUsage ? nUsage : GetFishInt(FISH_BAIT));
}

string GetFishingBait(object oEquipment = OBJECT_INVALID)
{
    if (!GetIsObjectValid(oEquipment))
        return Fish.Bait;

    return GetLocalString(oEquipment, FISH_BAIT);
}

void SetFishingBait(string sBait, object oEquipment = OBJECT_INVALID)
{
    if (!GetIsObjectValid(oEquipment))
        oEquipment = Fish.Item;

    SetLocalString(oEquipment, FISH_BAIT, sBait);
}

float GetFishFloat(string sVarName, string sFish = "")
{
    return GetLocalFloat(Fish.Data, sFish + sVarName);
}

int GetFishInt(string sVarName, string sFish = "")
{
    return GetLocalInt(Fish.Data, sFish + sVarName);
}

string GetFishString(string sVarName, string sFish = "")
{
    return GetLocalString(Fish.Data, sFish + sVarName);
}

void SetFishFloat(string sVarName, float fValue, string sFishList = "")
{
    int i;
    string sItem = GetListItem(sFishList, i);
    do
    {
        SetLocalFloat(Fish.Data, sItem + sVarName, fValue);
        sItem = GetListItem(sFishList, ++i);
    } while (sItem != "");
}

void SetFishInt(string sVarName, int nValue, string sFishList = "")
{
    int i;
    string sItem = GetListItem(sFishList, i);
    do
    {
        SetLocalInt(Fish.Data, sItem + sVarName, nValue);
        sItem = GetListItem(sFishList, ++i);
    } while (sItem != "");
}

void SetFishString(string sVarName, string sValue, string sFishList = "")
{
    int i;
    string sItem = GetListItem(sFishList, i);
    do
    {
        SetLocalString(Fish.Data, sItem + sVarName, sValue);
        sItem = GetListItem(sFishList, ++i);
    } while (sItem != "");
}

// Private function used by GetFishBy*() functions.
string GetFishList(string sListName, string sListType)
{
    // sanity check
    if (sListName == "")
        return "";

    // Resolve inheritance
    BuildFishList(sListName, sListType);
    return CompressList(Fish.Data, sListType + sListName);
}

string GetFishByEnvironment(string sEnvironment = "")
{
    if (sEnvironment == "")
        sEnvironment = Fish.Environment;

    return GetFishList(sEnvironment, FISH_ENVIRONMENT);
}

string GetFishByBait(string sBait = "")
{
    if (sBait == "")
        sBait == Fish.Bait;

    return GetFishList(sBait, FISH_BAIT);
}

string GetFishByEquipment(string sType = "")
{
    if (sType == "")
        sType = Fish.Type;

    return GetFishList(sType, FISH_EQUIPMENT);
}

void ActionFloatingTextString(string sMessage)
{
    ActionDoCommand(FloatingTextStringOnCreature(sMessage, Fish.PC, FALSE));
}

void ActionRemoveFishingBait()
{
    ActionDoCommand(DeleteLocalString(Fish.Item, FISH_BAIT));
}

void ActionCreateFish(string sResRef)
{
    ActionDoCommand(ObjectToAction(CreateItemOnObject(sResRef)));
}









void ObjectToAction(object oObject){}
